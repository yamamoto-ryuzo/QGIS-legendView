# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LegendViewDockWidget
                                 A QGIS plugin
 凡例を表示する
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-10-28
        git sha              : $Format:%H$
        copyright            : (C) 2020 by soja city.
        email                : none
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

#QMessageBox.information(self,'Message',type(layer).__name__,QMessageBox.Ok)

import os
import re
from io import BytesIO

# Import Qt compatibility module
from .qt_compat import *

from qgis.core import *
from qgis.gui import *

from operator import itemgetter

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'legend_view_dockwidget_base.ui'))


class LegendViewDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, iface, parent=None):
        """Constructor."""
        super(LegendViewDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface
        self.currentLayer = None
        self.root = QgsProject.instance().layerTreeRoot()

        # Qt5/Qt6 compatible orientation usage
        if is_qt5():
            vheader = QHeaderView(Qt.Vertical)
            hheader = QHeaderView(Qt.Horizontal)
        else:
            vheader = QHeaderView(QtOrientation.Vertical)
            hheader = QHeaderView(QtOrientation.Horizontal)
            
        self.tableWidget.setVerticalHeader(vheader)
        self.tableWidget.setHorizontalHeader(hheader)
        self.tableWidget.setHorizontalHeaderLabels([self.tr("シンボル"), self.tr("凡例")])
        self.tableWidget.setSelectionMode(NoSelection)
        self.styleComboBox.setVisible(False)
        self.styleLabel.setVisible(False)

        self.comboDataSet()
        self.comboBox.currentIndexChanged.connect(self.currentIndexChanged)
        self.mOpacityWidget.opacityChanged.connect(self.opacityChanged)
        
        # Qt5/Qt6 compatible signal connection
        try:
            # Try Qt6 approach first
            self.styleComboBox.currentTextChanged.connect(self.changeNamedStyle)
        except AttributeError:
            try:
                # Qt5 approach with QString
                self.styleComboBox.currentIndexChanged['QString'].connect(self.changeNamedStyle)
            except (KeyError, TypeError):
                # Fallback: use index changed and get text manually
                self.styleComboBox.currentIndexChanged.connect(self._styleComboBoxIndexChanged)
                
        self.comboBox.setCurrentIndex(-1)
        self.comboBox.setCurrentIndex(0)
        self.showLegend()

    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # Try Qt translation first
        translated = translate('LegendView', message)
        
        # If no translation found or same as original, try Python fallback
        if translated == message:
            try:
                from .i18n.translations import translate as py_translate
                # Get locale from QSettings
                try:
                    from qgis.PyQt.QtCore import QSettings
                    locale = QSettings().value('locale/userLocale', 'en')[0:2]
                except:
                    locale = 'ja'  # Default to Japanese
                    
                if locale not in ['ja', 'en']:
                    locale = 'en'
                    
                translated = py_translate('LegendView', message, locale)
            except ImportError:
                pass
        
        return translated

    def closeEvent(self, event):        
        self.closingPlugin.emit()
        event.accept()

    def showLegend(self):
        layer = self.currentLayer
        if layer is None:
            return

        # 名前付きスタイルリストの作成
        self.initNamedStyleList(layer)

        if isinstance(layer,QgsVectorLayer):
            symbols = layer.renderer().symbols(QgsRenderContext())
            legendItems = layer.renderer().legendSymbolItems()
            self.mOpacityWidget.setOpacity( layer.opacity())
            self.tableWidget.setVisible(True)
            self.tableWidget.horizontalHeader().setDefaultSectionSize(65)
            
            # Qt6 requires larger row height for better symbol display
            if is_qt6():
                self.tableWidget.verticalHeader().setDefaultSectionSize(30)  # Same as Qt5
            else:
                self.tableWidget.verticalHeader().setDefaultSectionSize(30)  # Standard for Qt5
                
            self.tableWidget.setRowCount(len(symbols))
            self.tableWidget.setColumnCount(2)
            self.tableWidget.horizontalHeader().setStretchLastSection(True)

            pm_icon_size = self.tableWidget.style().pixelMetric(PM_ListViewIconSize)
            
            # Use same size for both Qt5 and Qt6
            icon_size = QSize(self.tableWidget.columnWidth(0) - 10, pm_icon_size)

            i = 0
            for symbol in symbols:
                item1 = QTableWidgetItem()
                label = QLabel()
                # Use Qt version-specific alignment function
                setLabelAlignment(label)
                # Use Qt version-specific symbol preview function for better SVG support
                pixmap = createSymbolPreview(symbol, icon_size)
                label.setPixmap(pixmap)
                self.tableWidget.setCellWidget(i,0,label)
                i+=1

            j = 0
            for legendItem in legendItems :
                label = legendItem.label()
                other_item = not bool(label)
                item2 = QTableWidgetItem(self.tr("その他の値") if other_item else legendItem.label())                
                if other_item:
                    font = QFont()
                    font.setItalic(True)
                    item2.setFont(font)

                self.tableWidget.setItem(j,1,item2)
                j+=1
            
            self.listWidget.setVisible(False)

        if isinstance(layer,QgsRasterLayer):
            self.tableWidget.setVisible(False)
            self.listWidget.setVisible(True)
            self.mOpacityWidget.setOpacity( layer.renderer().opacity())
        
    def opacityChanged(self,opacity):
        layer = self.currentLayer
        if layer is None:
            return

        if isinstance(layer,QgsVectorLayer):
            layer.setOpacity(opacity)
        if isinstance(layer,QgsRasterLayer):
            layer.renderer().setOpacity(opacity)
        layer.triggerRepaint()

    def legendChanged(self):
        self.showLegend()
    
    def getLayer(self,groups):
        node = self.root

        for group in groups[:len(groups)-1]:
            next_node = node.findGroup(group)
            if isinstance(next_node, QgsLayerTreeGroup):
                node = next_node
            else:
                return None

        for child in node.children():
            if isinstance(child, QgsLayerTreeLayer):
                if child.name() == groups[len(groups)-1]:
                    return child.layer()

        return None

    def comboDataSet(self) :
        ecs = QgsExpressionContextUtils.projectScope(QgsProject.instance())
        slist = ecs.variableNames()
        layerIdList = []
        layerIdList2 = []
        for sstr in slist:
            if "legend_" not in sstr:
                continue
            layer_name = sstr.replace("legend_","")
            layer = self.getLayer(layer_name.split("_"))
            if isinstance(layer, QgsMapLayer) :
                # Get variable value and handle None safely
                variable_value = ecs.variable(sstr)
                self.distributeOrderList(layer.id(), layer_name, variable_value, layerIdList, layerIdList2)

        if len(layerIdList) > 0:
            layerIdList.sort(key=itemgetter(1))
        if len(layerIdList2) > 0:
            layerIdList2.sort(key=itemgetter(1))
        layerIdList.extend(layerIdList2)

        for layerid in layerIdList:
            layer = QgsProject.instance().mapLayer(layerid[0])
            icon = QIcon()
            if isinstance(layer,QgsRasterLayer):
                icon = QgsLayerItem.iconRaster()

            elif  isinstance(layer,QgsVectorLayer):
                if ( layer.geometryType() == QgsWkbTypes.PointGeometry ) :
                    icon = QgsLayerItem.iconPoint()
                elif ( layer.geometryType() == QgsWkbTypes.LineGeometry ) :
                    icon = QgsLayerItem.iconLine()
                elif ( layer.geometryType() == QgsWkbTypes.PolygonGeometry ) :
                    icon = QgsLayerItem.iconPolygon()
            else :
                continue

            self.comboBox.addItem(icon,layer.name(),layerid[0])
            # 対象レイヤの凡例変更シグナルを検知して処理する
            layer.legendChanged.connect(self.legendChanged)

    
    def currentIndexChanged(self,index):
        self.currentLayer = QgsProject.instance().mapLayer(self.comboBox.itemData(index))
        self.showLegend()

    def initNamedStyleList(self, layer: QgsMapLayer):
        # 名前付きスタイルリストを作成する

        self.styleComboBox.blockSignals(True)
        self.styleComboBox.setVisible(False)
        self.styleLabel.setVisible(False)
        self.styleComboBox.clear()

        if isinstance(layer, QgsMapLayer):
            manager = layer.styleManager()
            style_count = len(manager.styles())

            if style_count > 0:
                self.styleComboBox.setVisible(style_count > 1)
                self.styleLabel.setVisible(style_count > 1)

                for idx, name in enumerate(manager.styles()):
                    self.styleComboBox.addItem(name)
                    if name == manager.currentStyle():
                        self.styleComboBox.setCurrentIndex(idx)

        self.styleComboBox.blockSignals(False)

    def changeNamedStyle(self, styleName):
        # 指定の名前のレイヤスタイルにする
        self.currentLayer.styleManager().setCurrentStyle(styleName)

    def distributeOrderList(self, layer_id, layer_name, orderValue, numericList: list, nonNumericList: list):

        while True:
            # Check for None or QVariant null values first
            if orderValue is None or isinstance(orderValue, QVariant):
                break
            
            # Convert to string if not already
            if not isinstance(orderValue, str):
                try:
                    orderValue = str(orderValue)
                except:
                    break

            m = re.fullmatch(r"\d+", orderValue)
            if not m is None:
                numericList.append([layer_id, int(orderValue)])
                return

            n = re.fullmatch(r"\d*\.\d+", orderValue)
            if not n is None:
                numericList.append([layer_id, float(orderValue)])
                return
            
            break
        
        nonNumericList.append([layer_id, layer_name])

    def _styleComboBoxIndexChanged(self, index):
        """Fallback method for Qt5/Qt6 compatibility when currentTextChanged is not available"""
        if index >= 0:
            styleName = self.styleComboBox.itemText(index)
            self.changeNamedStyle(styleName)
